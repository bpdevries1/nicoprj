(* from https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm *)
(* some syntax errors in orig: logical-or-expression, logical-and-expression *)
(* maybe useful too: https://www.lysator.liu.se/c/ANSI-C-grammar-y.html and http://www.quut.com/c/ANSI-C-grammar-y.html *)

(* only one place at the start where ows can occur before a terminal/something *)
translation-unit ::= <ows> {external-declaration}*

external-declaration ::= function-definition | declaration

(* Add optional whitespace <ows>  => not only after terminals *)
function-definition ::= {<declaration-specifier>}* <declarator> {<declaration>}* <compound-statement>

(* van http://www.quut.com/c/ANSI-C-grammar-y.html, een yacc spec:

function_definition
	: declaration_specifiers declarator declaration_list compound_statement
	| declaration_specifiers declarator compound_statement
	;

Dit is bijna letterlijk hetzelfde.

*)

<declaration-specifier> ::= <storage-class-specifier>
                          | <type-specifier>
                          | <type-qualifier>

<storage-class-specifier> ::= 'auto' <ows>
                            | 'register' <ows>
                            | 'static' <ows>
                            | 'extern' <ows>
                            | 'typedef' <ows>

<type-specifier> ::= 'void' <ows>
                   | 'char' <ows>
                   | 'short' <ows>
                   | 'int' <ows>
                   | 'long' <ows>
                   | 'float' <ows>
                   | 'double' <ows>
                   | 'signed' <ows>
                   | 'unsigned' <ows>
                   | <struct-or-union-specifier>
                   | <enum-specifier>
                   | <typedef-name>

<struct-or-union-specifier> ::= <struct-or-union> <identifier> <ows> '{' <ows> {<struct-declaration>}+ '}' <ows>
                              | <struct-or-union> '{' <ows> {<struct-declaration>}+ '}' <ows>
                              | <struct-or-union> <identifier> <ows>

<struct-or-union> ::= 'struct' <ows>
                    | 'union' <ows>

<struct-declaration> ::= {<specifier-qualifier>}* <struct-declarator-list>

<specifier-qualifier> ::= <type-specifier>
                        | <type-qualifier>

<struct-declarator-list> ::= <struct-declarator>
                           | <struct-declarator-list> ',' <ows> <struct-declarator>

<struct-declarator> ::= <declarator>
                      | <declarator> ':' <ows> <constant-expression>
                      | ':' <ows> <constant-expression>

<declarator> ::= {<pointer>}? <direct-declarator>

<pointer> ::= '*' <ows> {<type-qualifier>}* {<pointer>}?

<type-qualifier> ::= 'const' <ows>
                   | 'volatile' <ows>

<direct-declarator> ::= <identifier> <ows>
                      | '(' <ows> <declarator> ')' <ows>
                      | <direct-declarator> '[' <ows>  {<constant-expression>}? ']' <ows> 
                      | <direct-declarator> '(' <ows>  <parameter-type-list> ')' <ows> 
                      | <direct-declarator> '(' <ows>  {<identifier> <ows>}* ')' <ows> 
                      
(* in yacc, dan meer varianten direct uitgeschreven, maar werkt mss beter?:


direct_declarator
	: IDENTIFIER
	| '(' declarator ')'
	| direct_declarator '[' ']'
	| direct_declarator '[' '*' ']'
	| direct_declarator '[' STATIC type_qualifier_list assignment_expression ']'
	| direct_declarator '[' STATIC assignment_expression ']'
	| direct_declarator '[' type_qualifier_list '*' ']'
	| direct_declarator '[' type_qualifier_list STATIC assignment_expression ']'
	| direct_declarator '[' type_qualifier_list assignment_expression ']'
	| direct_declarator '[' type_qualifier_list ']'
	| direct_declarator '[' assignment_expression ']'
	| direct_declarator '(' parameter_type_list ')'
	| direct_declarator '(' ')'
	| direct_declarator '(' identifier_list ')'
*)	                      

<constant-expression> ::= <conditional-expression>

<conditional-expression> ::= <logical-or-expression>
                           | <logical-or-expression> '?' <ows> <expression> ':' <ows> <conditional-expression>

<logical-or-expression> ::= <logical-and-expression>
                          | <logical-or-expression> '||' <ows> <logical-and-expression>

<logical-and-expression> ::= <inclusive-or-expression>
                           | <logical-and-expression> '&&' <ows> <inclusive-or-expression>

<inclusive-or-expression> ::= <exclusive-or-expression>
                            | <inclusive-or-expression> '|' <exclusive-or-expression>

<exclusive-or-expression> ::= <and-expression>
                            | <exclusive-or-expression> '^' <ows> <and-expression>

<and-expression> ::= <equality-expression>
                   | <and-expression> '&' <ows> <equality-expression>

<equality-expression> ::= <relational-expression>
                        | <equality-expression> '==' <ows> <relational-expression>
                        | <equality-expression> '!=' <ows> <relational-expression>

<relational-expression> ::= <shift-expression>
                          | <relational-expression> '<' <ows> <shift-expression>
                          | <relational-expression> '>' <ows> <shift-expression>
                          | <relational-expression> '<=' <ows> <shift-expression>
                          | <relational-expression> '>=' <ows> <shift-expression>

<shift-expression> ::= <additive-expression>
                     | <shift-expression> '<<' <ows> <additive-expression>
                     | <shift-expression> '>>' <ows> <additive-expression>

<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> '+' <ows> <multiplicative-expression>
                        | <additive-expression> '-' <ows> <multiplicative-expression>

<multiplicative-expression> ::= <cast-expression>
                              | <multiplicative-expression> '*' <ows> <cast-expression>
                              | <multiplicative-expression> '/' <ows> <cast-expression>
                              | <multiplicative-expression> '%' <ows> <cast-expression>

<cast-expression> ::= <unary-expression>
                    | '(' <ows> <type-name> ')' <ows> <cast-expression>

<unary-expression> ::= <postfix-expression>
                     | '++' <ows> <unary-expression>
                     | '--' <ows> <unary-expression>
                     | <unary-operator> <cast-expression>
                     | 'sizeof' <ows> <unary-expression>
                     | 'sizeof' <ows> <type-name>

<postfix-expression> ::= <primary-expression>
                       | <postfix-expression> '[' <ows> <expression> ']' <ows>
                       | <postfix-expression> '(' <ows> {<assignment-expression>}* ')' <ows>
                       | <postfix-expression> '.' <ows> <identifier> <ows>
                       | <postfix-expression> '->' <ows> <identifier> <ows>
                       | <postfix-expression> '++' <ows>
                       | <postfix-expression> '--' <ows>

<primary-expression> ::= <identifier> <ows>
                       | <constant>
                       | <string> <ows>
                       | '(' <ows> <expression> ')' <ows>

<constant> ::= <floating-constant> <ows>
             | <integer-constant> <ows>
             | <character-constant> <ows>
             | <enumeration-constant> <ows>

<expression> ::= <assignment-expression>
               | <expression> ',' <ows> <assignment-expression>

<assignment-expression> ::= <conditional-expression>
                          | <unary-expression> <assignment-operator> <assignment-expression>

<assignment-operator> ::= '=' <ows>
                        | '*=' <ows>
                        | '/=' <ows>
                        | '%=' <ows>
                        | '+=' <ows>
                        | '-=' <ows>
                        | '<<=' <ows>
                        | '>>=' <ows>
                        | '&=' <ows>
                        | '^=' <ows>
                        | '|=' <ows>

<unary-operator> ::= '&' <ows>
                   | '*' <ows>
                   | '+' <ows>
                   | '-' <ows>
                   | '~' <ows>
                   | '!' <ows>

<type-name> ::= {<specifier-qualifier>}+ {<abstract-declarator>}?

<parameter-type-list> ::= <parameter-list>
                        | <parameter-list> ',' <ows> '...' <ows>

<parameter-list> ::= <parameter-declaration>
                   | <parameter-list> ',' <ows> <parameter-declaration>

<parameter-declaration> ::= {<declaration-specifier>}+ <declarator>
                          | {<declaration-specifier>}+ <abstract-declarator>
                          | {<declaration-specifier>}+

<abstract-declarator> ::= <pointer>
                        | <pointer> <direct-abstract-declarator>
                        | <direct-abstract-declarator>

(* orig:  '(' <ows> {<parameter-type-list>|? ), so replaced | with '}' <ows> *)

<direct-abstract-declarator> ::=  '(' <ows> <abstract-declarator> ')' <ows>
                               | {<direct-abstract-declarator>}? '[' <ows> {<constant-expression>}? ']' <ows>
                               | {<direct-abstract-declarator>}? '(' <ows> {<parameter-type-list>}? ')' <ows>

<enum-specifier> ::= 'enum' <ows> <identifier> <ows> '{' <ows> <enumerator-list> '}' <ows>
                   | 'enum' <ows> '{' <ows> <enumerator-list> '}' <ows>
                   | 'enum' <ows> <identifier> <ows>

<enumerator-list> ::= <enumerator>
                    | <enumerator-list> ',' <ows> <enumerator>

<enumerator> ::= <identifier> <ows>
               | <identifier> <ows> '=' <ows> <constant-expression>

<typedef-name> ::= <identifier> <ows>

<declaration> ::=  {<declaration-specifier>}+ {<init-declarator>}*

<init-declarator> ::= <declarator>
                    | <declarator> '=' <ows> <initializer>

<initializer> ::= <assignment-expression>
                | '{' <ows> <initializer-list> '}' <ows>
                | '{' <ows> <initializer-list> ',' <ows> '}' <ows>

<initializer-list> ::= <initializer>
                     | <initializer-list> ',' <ows> <initializer>

(* bij deze is  al lastiger, want kan ook tussen declarations staat of tussen statements. En maakt dan geen onderdeel uit van het statement zelf. *)
(* alternatief is dat je dingen als statement in de def laat volgen door een ows. Dan eigenlijk elke finite char(s) laten volgen door  *)
<compound-statement> ::= '{' <ows> {<declaration>}* {<statement>}* '}' <ows>

(* <compound-statement> ::= '{' <ows> {<declaration>}* {<statement>}* '}' <ows> *)

<statement> ::= <labeled-statement>
              | <expression-statement>
              | <compound-statement>
              | <selection-statement>
              | <iteration-statement>
              | <jump-statement>

<labeled-statement> ::= <identifier> <ows> ':' <ows> <statement>
                      | 'case' <ows> <constant-expression> ':' <ows> <statement>
                      | 'default' <ows> ':' <ows> <statement>

<expression-statement> ::= {<expression>}? ';' <ows>

<selection-statement> ::= 'if' <ows> '(' <ows> <expression> ')' <ows> <statement>
                        | 'if' <ows> '(' <ows> <expression> ')' <ows> <statement> 'else' <ows> <statement>
                        | 'switch' <ows> '(' <ows> <expression> ')' <ows> <statement>

<iteration-statement> ::= 'while' <ows> '(' <ows> <expression> ')' <ows> <statement>
                        | 'do' <ows> <statement> 'while' <ows> '(' <ows> <expression> ')' <ows> ';' <ows>
                        | 'for' <ows> '(' <ows> {<expression>}? ';' <ows> {<expression>}? ';' <ows> {<expression>}? ')' <ows> <statement>

<jump-statement> ::= 'goto' <ows> <identifier> <ows> ';' <ows>
                   | 'continue' <ows> ';' <ows>
                   | 'break' <ows> ';' <ows>
                   | 'return' <ows> {<expression>}? ';' <ows>

(* added [2016-12-25 10:58]. Kan nu wel weer onderaan *)
<keyword> ::= 'auto' | 'break' | 'case' | 'char' | 'const' | 'continue' | 'default' | 'do' | 'double' | 'else' | 'enum' | 'extern' | 'float' | 'for' | 'goto' | 'if' | 'int' | 'long' | 'register' | 'return' | 'short' | 'signed' | 'sizeof' | 'static' | 'struct' | 'switch' | 'typedef' | 'union' | 'unsigned' | 'void' | 'volatile' | 'while'

(* use look ahead extension *)
<identifier> ::= !keyword #'[A-Za-z_][A-Za-z0-9_]*'

(* eigenlijk zou <ows> hier ook achter moeten, maar wil de whitespace niet bij de integer-constant etc hebben. Kan natuurlijk wel een string trim toepassen *)
(* [2016-12-27 20:39] 'for' <ows> now no exponential notation, is not the first thing that matches, maybe need to 'do' <ows> it outside of regexp. *)
(* <floating-constant> ::= #'[0-9]*\.[0-9]*([eE][+-]?[0-9]+)?' *)

<floating-constant> ::= #'[0-9]*\.[0-9]*'
<integer-constant> ::= #'[0-9]+'
<character-constant> ::= #'\'[^\']\''
(* <string> ::= #'\"[^\"]*\"' *)
(* <string> ::= #'"[^"]*"' *)

(* [2016-12-27 21:18] deze hieronder met regexp werkt wel voor vuser_end.c test met andere strings, maar duurt best (te?) lang voor landing.c *)
(* <string> ::= #'"([^\\"]|\\.)*"' *)
(* [2016-12-28 11:09] use chars instead of char, less memory *)

<string> ::= '"' {<chars> | <escaped-char>}* '"'
<chars> ::= #'[^\"\\]+'
<escaped-char> ::= #'\\.'

<enumeration-constant> ::= 'enumeration-constant'


(* handle white space, both optional (ows) and mandatory (mws) *)
(* comments should also be possible everywhere a whitespace is allowed, but want to handle this with pre-processing *)

<mws> ::= #'\s+'
<ows> ::= #'\s*'





