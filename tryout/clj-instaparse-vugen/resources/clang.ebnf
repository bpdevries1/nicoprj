(* from https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm *)
(* some syntax errors in orig: logical-or-expression, logical-and-expression *)
(* maybe useful too: https://www.lysator.liu.se/c/ANSI-C-grammar-y.html and http://www.quut.com/c/ANSI-C-grammar-y.html *)

(* only one place at the start where ows can occur before a terminal/something *)
translation-unit ::=  external-declaration+

external-declaration ::= function-definition | declaration

function-definition	::= declaration-specifiers declarator declaration-list compound-statement
	| declaration-specifiers declarator compound-statement

(* van http://www.quut.com/c/ANSI-C-grammar-y.html, een yacc spec:

Dit is bijna letterlijk hetzelfde.

*)

declaration-specifiers ::= storage-class-specifier declaration-specifiers
	| storage-class-specifier
	| type-specifier declaration-specifiers
	| type-specifier
	| type-qualifier declaration-specifiers
	| type-qualifier
	| function-specifier declaration-specifiers
	| function-specifier
	| alignment-specifier declaration-specifiers
	| alignment-specifier

alignment-specifier	::= 'alignas' '(' type-name ')'
	| 'alignas' '(' constant-expression ')'

function-specifier ::= 'inline' | 'noreturn'

declaration-list 	::= declaration
	| declaration-list declaration


<storage-class-specifier> ::= 'auto'
                            | 'register'
                            | 'static'
                            | 'extern'
                            | 'typedef'
                            | 'thread-local'

<type-specifier> ::= 'void'
                   | 'char'
                   | 'short'
                   | 'int'
                   | 'long'
                   | 'float'
                   | 'double'
                   | 'signed'
                   | 'unsigned'
                   | 'bool'
                   | 'complex'
                   | 'imaginary'
                   | <struct-or-union-specifier>
                   | <enum-specifier>
                   | <typedef-name>
                   | atomic-type-specifier

atomic-type-specifier ::= 'atomic' '(' type-name ')'

struct-or-union-specifier ::= struct-or-union '{' struct-declaration-list '}'
	| struct-or-union identifier '{' struct-declaration-list '}'
	| struct-or-union identifier

struct-declaration-list ::= struct-declaration
	| struct-declaration-list struct-declaration

<struct-or-union> ::= 'struct'
                    | 'union'

struct-declaration ::=specifier-qualifier-list ';'	
	| specifier-qualifier-list struct-declarator-list ';'
	| static-assert-declaration
	
specifier-qualifier-list ::=type-specifier specifier-qualifier-list
	| type-specifier
	| type-qualifier specifier-qualifier-list
	| type-qualifier

static-assert-declaration ::= 'static-assert'  '(' constant-expression ',' string ')' ';'

<struct-declarator-list> ::= <struct-declarator>
                           | <struct-declarator-list> ',' <struct-declarator>

<struct-declarator> ::= <declarator>
                      | <declarator> ':' <constant-expression>
                      | ':' <constant-expression>

declarator	::= pointer direct-declarator
	| direct-declarator

pointer	::= '*' type-qualifier-list pointer
	| '*' type-qualifier-list
	| '*' pointer
	| '*'

type-qualifier-list ::=type-qualifier
	| type-qualifier-list type-qualifier

<type-qualifier> ::= 'const'
                   | 'volatile' | 'atomic' | 'restrict'

direct-declarator ::=identifier
	| '(' declarator ')'
	| direct-declarator '[' ']'
	| direct-declarator '[' '*' ']'
	| direct-declarator '[' 'static' type-qualifier-list assignment-expression ']'
	| direct-declarator '[' 'static' assignment-expression ']'
	| direct-declarator '[' type-qualifier-list '*' ']'
	| direct-declarator '[' type-qualifier-list 'static' assignment-expression ']'
	| direct-declarator '[' type-qualifier-list assignment-expression ']'
	| direct-declarator '[' type-qualifier-list ']'
	| direct-declarator '[' assignment-expression ']'
	| direct-declarator '(' parameter-type-list ')'
	| direct-declarator '(' ')'
	| direct-declarator '(' identifier-list ')'
	                      
type-qualifier-list ::=type-qualifier
	| type-qualifier-list type-qualifier

identifier-list ::= identifier
	| identifier-list ',' identifier

<constant-expression> ::= <conditional-expression>

<conditional-expression> ::= <logical-or-expression>
                           | <logical-or-expression> '?' <expression> ':' <conditional-expression>

<logical-or-expression> ::= <logical-and-expression>
                          | <logical-or-expression> '||' <logical-and-expression>

<logical-and-expression> ::= <inclusive-or-expression>
                           | <logical-and-expression> '&&' <inclusive-or-expression>

<inclusive-or-expression> ::= <exclusive-or-expression>
                            | <inclusive-or-expression> '|' <exclusive-or-expression>

<exclusive-or-expression> ::= <and-expression>
                            | <exclusive-or-expression> '^' <and-expression>

<and-expression> ::= <equality-expression>
                   | <and-expression> '&' <equality-expression>

<equality-expression> ::= <relational-expression>
                        | <equality-expression> '==' <relational-expression>
                        | <equality-expression> '!=' <relational-expression>

<relational-expression> ::= <shift-expression>
                          | <relational-expression> '<' <shift-expression>
                          | <relational-expression> '>' <shift-expression>
                          | <relational-expression> '<=' <shift-expression>
                          | <relational-expression> '>=' <shift-expression>

<shift-expression> ::= <additive-expression>
                     | <shift-expression> '<<' <additive-expression>
                     | <shift-expression> '>>' <additive-expression>

<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> '+' <multiplicative-expression>
                        | <additive-expression> '-' <multiplicative-expression>

<multiplicative-expression> ::= <cast-expression>
                              | <multiplicative-expression> '*' <cast-expression>
                              | <multiplicative-expression> '/' <cast-expression>
                              | <multiplicative-expression> '%' <cast-expression>

<cast-expression> ::= <unary-expression>
                    | '(' <type-name> ')' <cast-expression>

<unary-expression> ::= <postfix-expression>
                     | '++' <unary-expression>
                     | '--' <unary-expression>
                     | <unary-operator> <cast-expression>
                     | 'sizeof' <unary-expression>
                     | 'sizeof' '(' <type-name> ')'
                     | 'alignof' '(' <type-name> ')'

postfix-expression	::= primary-expression
	| postfix-expression '[' expression ']'
	| postfix-expression '(' ')'
	| postfix-expression '(' argument-expression-list ')'
	| postfix-expression '.' identifier
	| postfix-expression '->' identifier
	| postfix-expression '++'
	| postfix-expression '--'
	| '(' type-name ')' '{' initializer-list '}'
	| '(' type-name ')' '{' initializer-list ',' '}'

<primary-expression> ::= <identifier> 
                       | <constant>
                       | <string> 
                       | '(' <expression> ')'
                       | generic-selection

generic-selection ::='generic'  '(' assignment-expression ',' generic-assoc-list ')'

generic-assoc-list ::= generic-association
	| generic-assoc-list ',' generic-association

generic-association ::=type-name ':' assignment-expression
	| 'default' ':' assignment-expression

<constant> ::= <floating-constant> 
             | <integer-constant> 
             | <character-constant> 
             | <enumeration-constant> 

<expression> ::= <assignment-expression>
               | <expression> ',' <assignment-expression>

<assignment-expression> ::= <conditional-expression>
                          | <unary-expression> <assignment-operator> <assignment-expression>

<assignment-operator> ::= '='
                        | '*='
                        | '/='
                        | '%='
                        | '+='
                        | '-='
                        | '<<='
                        | '>>='
                        | '&='
                        | '^='
                        | '|='

<unary-operator> ::= '&'
                   | '*'
                   | '+'
                   | '-'
                   | '~'
                   | '!'

type-name ::= specifier-qualifier-list abstract-declarator
	| specifier-qualifier-list

<parameter-type-list> ::= <parameter-list>
                        | <parameter-list> ',' '...'

<parameter-list> ::= <parameter-declaration>
                   | <parameter-list> ',' <parameter-declaration>

<parameter-declaration> ::= declaration-specifiers <declarator>
                          | declaration-specifiers <abstract-declarator>
                          | declaration-specifiers

<abstract-declarator> ::= <pointer>
                        | <pointer> <direct-abstract-declarator>
                        | <direct-abstract-declarator>

(* orig:  '(' parameter-type-list>|? ), so replaced | with '}' *)

direct-abstract-declarator ::= '(' abstract-declarator ')'
	| '[' ']'
	| '[' '*' ']'
	| '[' 'static' type-qualifier-list assignment-expression ']'
	| '[' 'static' assignment-expression ']'
	| '[' type-qualifier-list 'static' assignment-expression ']'
	| '[' type-qualifier-list assignment-expression ']'
	| '[' type-qualifier-list ']'
	| '[' assignment-expression ']'
	| direct-abstract-declarator '[' ']'
	| direct-abstract-declarator '[' '*' ']'
	| direct-abstract-declarator '[' 'static' type-qualifier-list assignment-expression ']'
	| direct-abstract-declarator '[' 'static' assignment-expression ']'
	| direct-abstract-declarator '[' type-qualifier-list assignment-expression ']'
	| direct-abstract-declarator '[' type-qualifier-list 'static' assignment-expression ']'
	| direct-abstract-declarator '[' type-qualifier-list ']'
	| direct-abstract-declarator '[' assignment-expression ']'
	| '(' ')'
	| '(' parameter-type-list ')'
	| direct-abstract-declarator '(' ')'
	| direct-abstract-declarator '(' parameter-type-list ')'

enum-specifier	::= 'enum' '{' enumerator-list '}'
	| 'enum' '{' enumerator-list ',' '}'
	| 'enum' identifier '{' enumerator-list '}'
	| 'enum' identifier '{' enumerator-list ',' '}'
	| 'enum' identifier

<enumerator-list> ::= <enumerator>
                    | <enumerator-list> ',' <enumerator>

enumerator	 ::= enumeration-constant '=' constant-expression
	| enumeration-constant

<typedef-name> ::= <identifier> 

<declaration> ::=  declaration-specifier+ init-declarator*

<init-declarator> ::= <declarator>
                    | <declarator> '=' <initializer>

<initializer> ::= <assignment-expression>
                | '{' <initializer-list> '}'
                | '{' <initializer-list> ',' '}'

<initializer-list> ::= <initializer>
                     | <initializer-list> ',' <initializer>

(* bij deze is  al lastiger, want kan ook tussen declarations staat of tussen statements. En maakt dan geen onderdeel uit van het statement zelf. *)
(* alternatief is dat je dingen als statement in de def laat volgen door een ows. Dan eigenlijk elke finite char(s) laten volgen door  *)
<compound-statement> ::= '{' declaration* statement* '}'

(* <compound-statement> ::= '{' declaration* statement* '}' *)

<statement> ::= <labeled-statement>
              | <expression-statement>
              | <compound-statement>
              | <selection-statement>
              | <iteration-statement>
              | <jump-statement>

<labeled-statement> ::= <identifier>  ':' <statement>
                      | 'case' <constant-expression> ':' <statement>
                      | 'default' ':' <statement>

<expression-statement> ::= expression? ';'

<selection-statement> ::= 'if' '(' <expression> ')' <statement>
                        | 'if' '(' <expression> ')' <statement> 'else' <statement>
                        | 'switch' '(' <expression> ')' <statement>

<iteration-statement> ::= 'while' '(' <expression> ')' <statement>
                        | 'do' <statement> 'while' '(' <expression> ')' ';'
                        | 'for' '(' expression? ';' expression? ';' expression? ')' <statement>

<jump-statement> ::= 'goto' <identifier>  ';'
                   | 'continue' ';'
                   | 'break' ';'
                   | 'return' expression? ';'

(* added [2016-12-25 10:58]. Kan nu wel weer onderaan *)
<keyword> ::= 'auto' | 'break' | 'case' | 'char' | 'const' | 'continue' | 'default' | 'do' | 'double' | 'else' | 'enum' | 'extern' | 'float' | 'for' | 'goto' | 'if' | 'int' | 'long' | 'register' | 'return' | 'short' | 'signed' | 'sizeof' | 'static' | 'struct' | 'switch' | 'typedef' | 'union' | 'unsigned' | 'void' | 'volatile' | 'while'

(* use look ahead extension *)
<identifier> ::= !keyword #'[A-Za-z_][A-Za-z0-9_]*'

(* eigenlijk zou  hier ook achter moeten, maar wil de whitespace niet bij de integer-constant etc hebben. Kan natuurlijk wel een string trim toepassen *)
(* [2016-12-27 20:39] 'for' now no exponential notation, is not the first thing that matches, maybe need to 'do' it outside of regexp. *)
(* <floating-constant> ::= #'[0-9]*\.[0-9]*([eE][+-]?[0-9]+)?' *)

<floating-constant> ::= #'[0-9]*\.[0-9]*'
<integer-constant> ::= #'[0-9]+'
<character-constant> ::= #'\'[^\']\''
(* <string> ::= #'\"[^\"]*\"' *)
(* <string> ::= #'"[^"]*"' *)

(* [2016-12-27 21:18] deze hieronder met regexp werkt wel voor vuser_end.c test met andere strings, maar duurt best (te?) lang voor landing.c *)
(* <string> ::= #'"([^\\"]|\\.)*"' *)
(* [2016-12-28 11:09] use chars instead of char, less memory *)

<string> ::= '"' {<chars> | <escaped-char>}* '"'
<chars> ::= #'[^\"\\]+'
<escaped-char> ::= #'\\.'

<enumeration-constant> ::= 'enumeration-constant'


(* handle white space, both optional (ows) and mandatory (mws) *)
(* comments should also be possible everywhere a whitespace is allowed, but want to handle this with pre-processing *)

<mws> ::= #'\s+'
<ows> ::= #'\s*'


(* deze waarschijnlijk straks niet meer nodig *)
<declaration-specifier> ::= <storage-class-specifier>
                          | <type-specifier>
                          | <type-qualifier>

<specifier-qualifier> ::= <type-specifier>
                        | <type-qualifier>


<enum-specifier> ::= 'enum-specifier'
<pointer> ::= 'pointer'
<declarator> ::= 'declarator'
<postfix-expression> ::= 'postfix-expression'
<enumerator> ::= 'enumerator'
