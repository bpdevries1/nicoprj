Scheidsrechters indelen.

Acties bij tweede helft seizoen (en misschien bij nieuw seizoen)
- uitgangspunt: bestaande wedstrijden blijven staan, net als scheidsrechters hierbij.
- uitgangspunt: wisselen van wedstrijden hier (nog) niet opnemen, wisselen doen mensen zelf maar.
- idee: kijk naar laatste wedstrijd met status gemaild. Verwijderd alle wedstrijden zonder een scheids.status=gemaild. 
  haal nieuwe NeVoBo wedstrijden op en insert, maar alleen wedstrijden na de laatste gemaild datum.
- de scheidsinfo niet opnieuw inlezen. Evt met de hand aanpassen: Baukelien en Chris niet op niet-speel avond. Check Ronald,
  want nu 2x geweest, zou niet weer moeten gebeuren.
=> niet meteen rondsturen, kijken wat er met Reza uitkomt, hij wil ook nog wat voor de vereniging fluiten. Als Reza vooral op 
  zaterdag extern fluit, moet dit lukken.
=> Ronald Schreuder heeft nu nog een wedstrijd op niet speelavond. Mogelijk in combi met Reza op te lossen.
=> aanwijsoverzicht van Reza t/m november importeren, zie "actuele aanwijsoverzicht tot en met 27 februari 2011.xlsx"
=> Idee: thuis-factor bij Baukelien en Chris op 0,9 zetten, dan fluiten ze thuis wanneer het maar kan. Voor Ronald bv op 1.5 zetten.
  
Acties bij nieuw seizoen.

* scheids.xls up-to-date maken:
  - wie zijn regio scheidsen
  - kloppen de teams van de scheidsen nog?
* Maken scheids.tsv, export van scheids.xls, hier updates in bijhouden.
* Downloaden wedstrijden, vraag of thuis/schuilenburg wedstrijden apart opgehaald moeten worden.
* empty.sql, met schone lei beginnen.
* insert-input.tcl - met beleid, kijk naar proc-namen:o
  - insert_teams - nu (12-9-2010) niet gedaan, zelfde als vorig jaar.
  - insert_personen
  - insert_afwezig: met de hand, bv eigen vakantie en ester alleen oktober. @todo Wel periodes kunnen doen.
  - insert_persoon_team: met de hand, nu alleen losse queries. Hier ook 2 coaches en een scheids.
  - insert_thuis_wedstrijden: niet nodig!
  - insert_team_wedstrijden: haalt wedstrijden op van nevobo site naar bestand en leest deze in DB.
  - insert_kan_wedstrijd_fluiten: losse queries?
  - delete_kan_wedstrijd_fluiten: ook nodig? komt 2x voor:
    - eerste om obv afwezig en persoon_team combi's te verwijderen.
    - tweede om obv gemaakte keuze (status=gemaild) de alternatieven te verwijderen.
  - insert_zeurfactor: was default, lees nu in via excel sheet.
  - doe_checks: controles of elke wedstrijd een scheids heeft.
* handmatige aanpassingen in DB: wanneer kan iemand niet bv. Ester is zwanger bv, alleen oktober.
* verwijder evt eerste of tweede helft van de competitie (ook bv delete_2011 in .tcl)
* maak-voorstel.tcl
* maak-tsv.tcl - om het voorstel in tsv te zetten om rond te sturen.


Technische verhandeling:

Als maak-voorstel traag is, dan ook hier record door dict vervangen.

if {0} {
  wat aandachtspunten bij het verdelen:
  1. als er mensen zelfde dag spelen, dan hier altijd uit kiezen, ook al fluiten deze al veel.
  2. uit 1. blijkt dat zelfde dag spelen eerst gevuld moet worden, en dan hier aantallen van bepaald voor betreffende scheids.
  3. voor mensen die niet in een team spelen, kunnen ze nooit op dezelfde dag, dus dan hier ook niet op letten, wel op het totaal.
  4. optimaal: ieder fluit even veel. 
  5. om klachten te voorkomen/pareren: degene die het meest fluit, fluit niet (veel) meer dan de anderen.
  6. om klachten te voorkomen/pareren: degene die in een team speelt, maar het meest op andere dagen fluit, doet dit niet (veel) meer dan anderen
     in dezelfde situatie.
  
  Fase 1 - zelfde dag.
  1. Ofwel beginnen met wedstrijden waar de minste scheidsen voor te vinden zijn, minimaal 1.
  1a. steeds selectie opnieuw doen: minste scheidsen te vinden, nog niet ingepland, op volgorde van diegene waarbij som van al ingepland en kan-nog-fluiten
      met kleinste som dus eerst.
  1b. Na invulling van een wedstrijd de kan-fluiten-tabel bijwerken, records weg: zowel van wedstrijd, alsook van persoon op dit tijdstip.
  2. ofwel beginnen met de scheids die het minst aantal wedstrijden kan fluiten, ook minimaal 1.

  Andere manier is back tracking, maar dan dus wel nodig om situatie te kunnen herstellen. scheids-entry verwijderen lukt wel, maar undeleten kan-fluiten
  is lastiger. Iets doen met 'gekozen' veld? of 'verwijderd'? of 'voorstel': voorstel=1: dit is 'em, voorstel = 0, niet gekozen. voorstel = leeg/null: nog openstaand.
  null en 0 niet beide gebruiken, ofwel: 0 is nog te kiezen, -1 is niet, +1 is wel. Bij een wedstrijd moeten dan altijd alle kan-wedstrijd ofwel op 0 staan,
  ofwel op -1 en +1.
  Moet eigenlijk nog iets tussen 'voorstel' van het selectie-algoritme en de persoonlijke goedkeuring hiervan, nadat diverse dingen zijn gecheckt.
  
  Met backtracking: je weet aantal wedstrijden dat in principe gevuld kan worden door scheids die dezelfde dag speelt, dit is dan ook het doel, elk van
  deze wedstrijden zo vullen. Optimaliseren door:
  * zo veel mogelijk verschillende mensen die dit doen.
  * Gemiddelde wat deze mensen fluiten is bij elke oplossing gelijk. Kan bv zeggen dat de standaard deviatie hiervan zo klein mogelijk moet zijn. 2/2/2
    is dan beter dan 1/2/3.
    
  Voor fase 2 eigenlijk een vergelijkbaar algoritme.
  
  TODO:
  * Astrid kan maar 1 wedstrijd op eigen dag fluiten, haar dus ook hier voor indelen, en dan niet Debbie, waarvoor hetzelfde geldt. Evt wel debbie als backup.
  * Voor Astrid vanwege kinderen extra sneu als ze op andere dag moet fluiten.
  
}

# een oplossing met lijst van wedstrijden en statistieken over deze oplossing
# @todo? ook lijst van scheids en aantal wedstrijden dat 'ie fluit, ook op dezelfde dag. Maar dit ook wel uit DB te query-en.
# max_scheids: maximum van aantal wedstrijden dat een scheids fluit.
record define rec_oplossing {
  solnr
  solnr_parent
  n_versch_scheids
  std_n_wedstrijden
  max_scheids
  som_zeurfactoren
  lst_zeurfactoren
  lst_aantallen
  note
  fitness
  prod_wedstrijden_persoon_dag
  lst_opl_scheids
  lst_opl_persoon_info
}

record define opl_scheids {
  wedstrijd_id
  wedstrijd_naam
  datum
  zelfde_dag
  scheids_id
  scheids_naam
}

record define opl_persoon_info {
  scheids_id
  scheids_naam
  nfluit
  zeurfactor
}

record define inp_wedstrijd {
   wedstrijd_id
   wedstrijd_naam
   datum
   -- zelfde_dag
   lst_kan_fluiten
}

# record binnen lst_kan_fluiten van inp_wedstrijd: wie kan de wedstrijd fluiten?
# n_kan_fluiten => aantal wedstrijden die scheids totaal kan fluiten voor waarde van zelfde dag!
# @note geen comment achter de field-defs, want dan worden dit ook field-defs....
record define inp_kan_fluiten {
  scheids_id
  scheids_naam
  zelfde_dag
  waarde
  zeurfactor
}

record define inp_persoon {
  scheids_id
  scheids_naam
  nfluit
  zeurfactor
}

