#!/usr/bin/env tclsh86

# har2db.tcl - read .har files generated by Webpagetest into sqlite db.
# first to determine correlation between slow loading and not in Akamai cache.

package require Tclx
package require ndv
package require json

set log [::ndv::CLogger::new_logger [file tail [info script]] info]
$log set_file "[file tail [info script]].log"

proc main {argv} {
  log debug "argv: $argv"
  set options {
    {dir.arg "c:/projecten/Philips/CQ5-CN-WPT" "Directory with .har files and also sqlite db"}
    {newdb "Recreate DB, delete first"}
    {moveread "Move read .har files to read subdir"}
    {loglevel.arg "info" "Log level (debug, info, warn)"}
  }
  set usage ": [file tail [info script]] \[options] :"
  set dargv [getoptions argv $options $usage]
  read_hars $dargv
}

proc read_hars {dargv} {
  set db [get_db [file join [:dir $dargv] hars.db] [:newdb $dargv]]
  foreach har_file [glob -directory [:dir $dargv] *.har] {
    read_har $db $har_file
    if {[:moveread $dargv]} {
      file mkdir [file join [:dir $dargv] read]
      file rename $har_file [file join [:dir $dargv] read]
    }
  }
}

proc get_db {db_name newdb} {
  if {$newdb} {
    file delete $db_name
  }
  set existing_db [file exists $db_name]
  set db [dbwrapper new $db_name]
  define_tables $db
  if {!$existing_db} {
    log info "New db: $db_name, create tables"
    $db create_tables 0 ; # 0: don't drop tables first.
  } else {
    log info "Existing db: $db_name, don't create tables"
  }
  $db prepare_insert_statements
  return $db  
}

proc read_har {db har_file} {
  log info "read har: $har_file"
  $db in_trans {
    set location [det_location $har_file]
    set file_id [$db insert harfile [dict create path $har_file filename [file tail $har_file] ts_cet [file_ts_cet $har_file] location $location]]
    set root [-> $har_file read_file json::json2dict]
    foreach e [-> $root :log :entries] {
      insert_entry $db $file_id $location $e
    }
  }
}

proc file_ts_cet {filename} {
  clock format [file atime $filename] -format "%Y-%m-%d %H:%M:%S"
}

proc det_location {filename} {
  if {[regexp {\(([^.]+)\)} [file tail $filename] z loc]} {
    string tolower $loc
  } else {
    file tail $filename
  }
}

proc insert_entry {db harfile_id location e} {
  set url [-> $e :request :url]
  set resp [:response $e]
  set status [:status $resp]
  set bodysize [:bodySize $resp]
  set ip_address [:_ip_addr $e]
  set loadtime [:_load_ms $e]
  set ttfb [:_ttfb_ms $e]
  dict_to_vars [:timings $e]  
  # {name Powered-By-ChinaCache value {MISS from BGP-GZ-1-3T8}} 
  set hsak [listc {$h} h <- [:headers $resp] {([:name $h] == "X-Cache") || ([:name $h] == "Powered-By-ChinaCache")}]
  # set ak_header [-> $hsak :0 :value]
  set ak_header [join [listc {[:value $h]} h < $hsak] "; "]
  set ak_cache [det_ak_cache $ak_header]
  set json [json::dict2json $e]
  $db insert pageitem [vars_to_dict harfile_id location url status bodysize \
      ip_address loadtime blocked dns connect ssl send wait receive ttfb ak_header ak_cache json] 
}

# ook vraag of deze info los van Akamai in headers wordt gegeven.
proc det_ak_cache {ak_header} {
  # idee: alle woorden in string waar MISS of HIT instaat; deze met ; concatten.
  join [listc {$el} el <- [split $ak_header " "] {[regexp {(HIT)|(MISS)} $el]}] "; "
}

# ook vraag of deze info los van Akamai in headers wordt gegeven.
proc det_ak_cache_old {ak_header} {
  if {[regexp {^([^ ]+)} $ak_header z cache]} {
    return $cache
  } else {
    return $ak_header
  }
}

proc define_tables {db} {
  # for now, only the essentials to analyse Akamai cache correlation.
  $db add_tabledef harfile {id} {path filename ts_cet location}
  $db add_tabledef pageitem {id} {harfile_id location url {status int} {bodysize int} ip_address {loadtime int} {blocked int} {dns int} 
                                  {connect int} {ssl int} {send int} {wait int} {receive int} {ttfb int} ak_header ak_cache json}
}

# Clojure threading operator. This only only works on single parameter functions/procs.
proc -> {x args} {
  foreach arg $args {
    set x [$arg $x]
  }
  return $x
}

main $argv
